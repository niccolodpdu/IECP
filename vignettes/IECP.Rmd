---
title: "IECP User Maunal"
author: "Dongping Du"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{IECP User Maunal}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

Cell-type asymmetry in expression profiles can substantially impact the outcomes of reference-free deconvolution. To address this, we proposed IECP which aims to enhance the accuracy of proportion inference under the influence of cell-type asymmetry. IECP iteratively identifies Consistently Expressed Genes (CEGs) across the cell-type expression profiles in S after each round of deconvolution and uses these CEGs to normalize the bulk expression matrix X.
\
\


# Quick Start
You can install the latest version of IECP from GitHub by

```{r Install, eval = FALSE}
devtools::install_github("niccolodpdu/IECP")
```

Starting your analysis by `IECP()` where you need to specify the input matrix `X` where samples on columns and features on rows; `K`, the number of sources/cell types/sub-types; `deconvo_func`, the deconvolution function used in IECP; `deconvo_param`, a list of parameters used in the deconvolution function specified by the user and `A_deconvo`, the relative address of A matrix (mixing proportion matrix) from the deconvolution output. Other parameters are optional. If your preferred deconvolution algorithm requires certain feature selection method, you need to include these in IECP by specifying `feat_sele_func` and `feat_sele_param`, referring to the function used for feature selection and a list of parameters used in the feature selection function, respectively. Using 'csDeconv' as an example:

```{r Demo, eval=FALSE}
test_result<-IECP(X = X_input, 
                  K = 5, 
                  deconvo_func = csDeconv,
                  deconvo_param =list(Y_raw = X_input, K = 5, TotalIter = 30, 
                                      bound_negative = TRUE, nMarker = 2000),
                  feat_sele_func = findRefinx,
                  feat_sele_param = list(rawdata=X_input, nmarker = 5000),
                  A_deconvo = '$estProp')
```
\


# Realisitic simulation
## Simulated proportion matrix A

The sample-wise cell-type proportion matrix is simulated by the Dirichlet distribution function. Dirichlet distribution allows an overall balanced cell-type proportion among samples without assuming the existence of 'ideally pure samples' of certain cell types, as in most cases pure samples are not available or unknown for the deconvolution. We set Î± (the parameter controlling the shape of the distribution) at 3 for all cell types in our simulation to make sure the proportions among samples are basically concentrated towards the center and mutually symmetric. Here we provide an example A matrix for users' reference.

```{r A Read-in,message=FALSE}
## Read-in
library(IECP)
A<-IECP::sample_proportion_matrix

```

## Cell-type specific expression profiles from GSE73721

The synthetic bulk data X is generated by multiplying the cell type specific expression profiles S extracted from real-world genomics data with a simulated sample-wise cell-type proportion matrix A. In this manual the cell type specific expression profiles are extracted from GSE73721, an expression profiling on RNA-Seq of human brain cells (Zhang et al., 2016). Five cell types were extracted from the original data: HepaCAM positive cells (Astrocyte), GalC positive cells (Oligodendrocyte), CD45 positive cells (Myeloid), BSL bound cells (Endothelial), and O4 positive cells (Oligodendrocyte), all from adult temporal lobe. Here we provided an pre-processed example cell-type specific expression profile for users to use as a reference.

```{r S Read-in,message=FALSE,fig.height=7, fig.width=7, fig.align='left'}
## Read-in
S<-IECP::sample_expression_profile

# Mixing S and A into X
X <- S %*% t(A)

# Visualizing S matrix and the cell-type specific markers
cot<-cotMG(Sest=S,cos.thres=0.5,top=1500)
scatter_plot(S,mg.info = TRUE,mg=cot$mg.list)
```

The above plot is the gene scatter plot in the cell-type space for cell type specific expression profile extracted from GSE73721. Marker genes for each cell type are identified by COT and are colored accordingly. Triangles at the vertices are the ideal marker genes that uniquely express in a certain cell type, used as the coordinates for the cell-type space.

## Applying IECP on four different unsupervised deconvolution algorithms

To validate the applicability of IECP on different unsupervised deconvolution algorithms, we firstly applied IECP to our in-house deconvolution method *CAM3.0*

```{r Library Loading, warning=FALSE,fig.height=7, fig.width=7, fig.align='left',message=FALSE}
## Loading necessary libraries
library(CAM3)
library(PREDE)
library(debCAM)
library(TOAST)
library(preprocessCore)
```

The following codes shows how we integrate **CAM3.0** by Wu et al., 2024 without and with applying the IECP pipeline, with both quantitative evaluation and graphical illustration on the effect of IECP on improving the accuracy of deconvolution.

Firstly, CAM3.0 without applying IECP:

```{r CAM3.0 Without IECP, message=FALSE,results='hide',warning=FALSE}
### CAM3.0
data_input<-X/max(X)

#### Without IECP ####
rCAM<-CAM3Run(data=data_input, K=5, dim.rdc = 10, thres.low = 0.3, thres.high = 0.99,
              cluster.method = 'Fixed-Radius', fast.mode = TRUE,
              radius.thres = 0.99, sim.thres = 0.98, cluster.num = 30,
              MG.num.thres = 5, sample.weight = NULL, generalNMF = FALSE)

A_CAM<-rCAM@ASestResult[[1]]@Aest

# Calculate Correlation Score
cor_CAM<-cor(A_CAM, A)
CAM_output_cor<-mean(apply(cor_CAM, 2, max))

# Calculate RMSE
order_output<-apply(cor_CAM,1,function(x) which.max(x))
CAM_output_rmse<-sqrt(mean((A_CAM[,order(order_output)] - A)^2))

# Calculate Cosine
cosine<-matrix(nrow=dim(A)[2],ncol=dim(A)[2])
for (i in 1:dim(A)[2]){
  for (j in 1:dim(A)[2]){
    cosine[i,j]<-mycosine(A[,i],A_CAM[,j])
  }
}
CAM_output_cosine<-mean(apply(cosine,2,max))
```

CAM3.0 with applying IECP:

```{r CAM3.0 With IECP, message=FALSE,results='hide',warning=FALSE}
#### With IECP ####
test_result<-IECP(X=data_input,K=5,iCEG_thres=0.95,iteration=20,removal = 1,
                  deconvo_func = CAM3Run,
                  deconvo_param = list(data=data_input,K=5, dim.rdc = 10, thres.low = 0.3, thres.high = 0.99, 
                                       fast.mode = TRUE,radius.thres = 0.99, sim.thres = 0.98, cluster.num = 30,
                                       MG.num.thres = 5,sample.weight = NULL, generalNMF = FALSE),
                  A_deconvo = '@ASestResult[[1]]@Aest',
                  S_deconvo = '@ASestResult[[1]]@Sest')

A_CAM_IECP<-test_result[[1]][[as.numeric(test_result[[4]])]]

# Calculate Correlation Score
cor_CAM_IECP<-cor(A_CAM_IECP, A)
CAM_IECP_output_cor<-mean(apply(cor_CAM_IECP, 2, max))

# Calculate RMSE
order_IECP_output<-apply(cor_CAM_IECP,1,function(x) which.max(x))
CAM_IECP_output_rmse<-sqrt(mean((A_CAM_IECP[,order(order_IECP_output)] - A)^2))

# Calculate Cosine
cosine<-matrix(nrow=dim(A)[2],ncol=dim(A)[2])
for (i in 1:dim(A)[2]){
  for (j in 1:dim(A)[2]){
    cosine[i,j]<-mycosine(A[,i],A_CAM_IECP[,j])
  }
}
CAM_IECP_output_cosine<-mean(apply(cosine,2,max))
```

Quantitative Evaluation of the accuracy of proportion inference for CAM3.0, with and without applying the IECP pipeline:

```{r CAM3.0 Quantitative Evaluation, warning=FALSE}
#### Quantitative Evaluation ####
# Correlation Score
print(paste('Before IECP:',CAM_output_cor))
print(paste('After IECP:',CAM_IECP_output_cor))

# RMSE
print(paste('Before IECP:',CAM_output_rmse))
print(paste('After IECP:',CAM_IECP_output_rmse))

# Cosine
print(paste('Before IECP:',CAM_output_cosine))
print(paste('After IECP:',CAM_IECP_output_cosine))
```

Graphical illustration of the cell-type scatter plot of CAM3.0, without applying IECP:

```{r CAM3.0 Plot 1, warning=FALSE,message=FALSE,fig.height=7, fig.width=7, fig.align='left'}
# Without IECP
scatter_plot(rCAM@ASestResult[[1]]@Sest[,order(order_output)],mg.info = TRUE,mg=cot$mg.list)
```

It's clear that compared to the ground truth, many marker genes (highlighted in different colors) are falsely shifted. Now let's take a look at the one with applying IECP:

```{r CAM3.0 Plot 2, warning=FALSE,message=FALSE,fig.height=7, fig.width=7, fig.align='left'}
# With IECP
scatter_plot(test_result$`S list`[[test_result[[4]]]][,order(order_IECP_output)],mg.info = TRUE,mg=cot$mg.list)

```

Marker genes are now much closer to their ground truth location.

Similarly, we can apply IECP to other deconvolution methods like **PREDE** (Qin et al., 2020):

```{r PREDE, eval=FALSE}
#### With IECP ####
test_result<-IECP(X = X_input, K = 5, iCEG_thres = 0.95, iteration = 20, removal = 1,
                  deconvo_func = PREDE,
                  deconvo_param = list(Y=X_input,W1=NULL,type ="GE",K = 5,iters = 50,rssDiffStop = 1e-5),
                  feat_sele_func = select_feature,
                  feat_sele_param = list(mat = X_input,method = "cv",nmarker = 1000, startn = 0),
                  A_deconvo = '$H')
```

**RefFreeEWAS** by Houseman et al., 2016

```{r RefFreeEWAS, eval=FALSE}
#### With IECP ####
test_result<-IECP(X = X_input, K = 5, iCEG_thres= 0.95, iteration = 20, removal = 1,
                  deconvo_func = RefFreeCellMix,
                  deconvo_param = list(Y = X_input, K = 5, verbose = FALSE),
                  feat_sele_func = select_most_variant,
                  feat_sele_param = list(input=X_input,k=10000),
                  A_deconvo = '$Omega')
```

**TOAST** by Li & Wu, 2019

```{r TOAST, eval=FALSE}
#### With IECP ####
test_result<-IECP(X = X_input, K = 5, iCEG_thres = 0.95, iteration = 20, removal = 1,
                  deconvo_func = csDeconv,deconvo_param =list(Y_raw = X_input, K = 5, TotalIter = 30, 
                                                              bound_negative = TRUE, nMarker = 2000),
                  feat_sele_func = findRefinx,feat_sele_param = list(rawdata=X_input, nmarker = 5000),
                  A_deconvo = '$estProp')
```

# Reference
Houseman, E. Andres, et al. "Reference-free deconvolution of DNA methylation data and mediation by cell composition effects." BMC bioinformatics 17 (2016): 1-15.

Qin, Yufang, et al. "Deconvolution of heterogeneous tumor samples using partial reference signals." PLOS Computational Biology 16.11 (2020): e1008452.

Wu, C. T. et al. CAM3.0: determining cell-type composition and expression from bulk tissues with fully unsupervised deconvolution. Bioinformatics 40 (2024).

Li, Z., Wu, H. TOAST: improving reference-free cell composition estimation by cross-cell type differential analysis. Genome Biol 20, 190 (2019). 

Zhang, Ye et al. âPurification and Characterization of Progenitor and Mature Human Astrocytes Reveals Transcriptional and Functional Differences with Mouse.â Neuron vol. 89,1 (2016): 37-53.