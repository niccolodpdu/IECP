---
title: "ITEA User Maunal"
author: "Dongping Du"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{ITEA User Maunal}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

Cell-type asymmetry in expression profiles can substantially impact the outcomes of reference-free deconvolution. To address this, we proposed ITEA which aims to enhance the accuracy of proportion inference under the influence of cell-type asymmetry. ITEA iteratively identifies Consistently Expressed Genes (CEGs) across the cell-type expression profiles in S after each round of deconvolution and uses these CEGs to normalize the bulk expression matrix X.

## Quick Start

You can install the latest version of ITEA from GitHub by

```{r Install, eval = FALSE}
devtools::install_github("niccolodpdu/ITEA")
```

## Loading simulated proportion matrix A

The sample-wise cell-type proportion matrix is simulated by the Dirichlet distribution function. Dirichlet distribution allows an overall balanced cell-type proportion among samples without assuming the existence of 'ideally pure samples' of certain cell types, as in most cases pure samples are not available or unknown for the deconvolution. We set Î± (the parameter controlling the shape of the distribution) at 3 for all cell types in our simulation to make sure the proportions among samples are basically concentrated towards the center and mutually symmetric. Here we provide an example A matrix for users' reference.

```{r A Read-in,message=FALSE}
## Read-in
library(ITEA)
A<-ITEA::sample_proportion_matrix

```

## Loading pre-processed cell-type specific expression profiles from GSE73721

The synthetic bulk data X is generated by multiplying the cell type specific expression profiles S extracted from real-world genomics data with a simulated sample-wise cell-type proportion matrix A. In this manual the cell type specific expression profiles are extracted from GSE73721, an expression profiling on RNA-Seq of human brain cells. Five cell types were extracted from the original data: HepaCAM positive cells (Astrocyte), GalC positive cells (Oligodendrocyte), CD45 positive cells (Myeloid), BSL bound cells (Endothelial), and O4 positive cells (Oligodendrocyte), all from adult temporal lobe. Here we provided an pre-processed example cell-type specific expression profile for users to use as a reference.

```{r S Read-in,message=FALSE,fig.height=7, fig.width=7, fig.align='left'}
## Read-in
S<-ITEA::sample_expression_profile
S<-t(S)

# Mixing S and A into X
X <- S %*% t(A)

# Visualizing S matrix and the cell-type specific markers
cot<-cotMG(Sest=S,cos.thres=0.5,top=1500)
scatter_plot(S,mg.info = TRUE,mg=cot$mg.list)
```

## Applying ITEA on four different unsupervised deconvolution algorithms

To validate the applicability of ITEA on different unsupervised deconvolution algorithms, we included four popular methods (**CAM3.0**, **TOAST**, **PREDE**, **RefFreeEWAS**). Three of these methods embedded specific feature selection units as a part of their procedure (PREDE, TOAST, RefFreeEWAS), which were also integrated into the ITEA pipeline.

```{r Library Loading, warning=FALSE,fig.height=7, fig.width=7, fig.align='left',message=FALSE}
## Loading necessary libraries
library(CAM3)
library(PREDE)
library(debCAM)
library(TOAST)
library(preprocessCore)
```

The following codes shows how we integrate **CAM3.0** by Wu et al., 2024 with our ITEA pipeline, with both quantitative evaluation and graphical illustration of the effect of ITEA on improving the accuracy of deconvolution.

```{r CAM3.0, message=FALSE,results='hide',warning=FALSE,fig.height=5, fig.width=6, fig.align='left'}
### CAM3.0
data_input<-X

#### Without ITEA ####
rCAM<-CAM3Run(data=data_input, K=5, dim.rdc = 10, thres.low = 0.3, thres.high = 0.99,
                 cluster.method = 'Fixed-Radius', fast.mode = TRUE,
                 radius.thres = 0.99, sim.thres = 0.98, cluster.num = 30,
                 MG.num.thres = 5, sample.weight = NULL, generalNMF = FALSE)

A_CAM<-rCAM@ASestResult[[1]]@Aest

# Correlation score
cor_CAM<-cor(A_CAM, A)
CAM_output_cor<-mean(apply(cor_CAM, 2, max))

# RMSE
order_output<-apply(cor_CAM,1,function(x) which.max(x))
CAM_output_rmse<-sqrt(mean((A_CAM[,order(order_output)] - A)^2))

# Cosine
cosine<-matrix(nrow=dim(A)[2],ncol=dim(A)[2])
for (i in 1:dim(A)[2]){
  for (j in 1:dim(A)[2]){
    cosine[i,j]<-mycosine(A[,i],A_CAM[,j])
  }
}
CAM_output_cosine<-mean(apply(cosine,2,max))

#### With ITEA ####
test_result<-ITEA(X=data_input,K=K,iCEG_thres=0.95,iteration=20,removal = 1,
                     deconvo_func = CAM3Run,
                     deconvo_param = list(data=data_input,K=5, dim.rdc = 10, thres.low = 0.3, thres.high = 0.99, 
                                          fast.mode = TRUE,radius.thres = 0.99, sim.thres = 0.98, cluster.num = 30,
                                          MG.num.thres = 5,sample.weight = NULL, generalNMF = FALSE),
                     A_deconvo = '@ASestResult[[1]]@Aest',
                     S_deconvo = '@ASestResult[[1]]@Sest')

A_CAM_ITEA<-test_result[[1]][[as.numeric(test_result[[4]])]]

# Correlation score
cor_CAM_ITEA<-cor(A_CAM_ITEA, A)
CAM_ITEA_output_cor<-mean(apply(cor_CAM_ITEA, 2, max))

# RMSE
order_ITEA_output<-apply(cor_CAM_ITEA,1,function(x) which.max(x))
CAM_ITEA_output_rmse<-sqrt(mean((A_CAM_ITEA[,order(order_ITEA_output)] - A)^2))

# Cosine
cosine<-matrix(nrow=dim(A)[2],ncol=dim(A)[2])
for (i in 1:dim(A)[2]){
  for (j in 1:dim(A)[2]){
    cosine[i,j]<-mycosine(A[,i],A_CAM_ITEA[,j])
  }
}
CAM_ITEA_output_cosine<-mean(apply(cosine,2,max))
```

Quantitative Evaluation for CAM3.0 before and after applying the ITEA pipeline
```{r CAM3.0 Quantitative Evaluation, warning=FALSE}
#### Quantitative Evaluation ####
# Correlation Score
print(paste('Before ITEA:',CAM_output_cor))
print(paste('After ITEA:',CAM_ITEA_output_cor))

# RMSE
print(paste('Before ITEA:',CAM_output_rmse))
print(paste('After ITEA:',CAM_ITEA_output_rmse))

# Cosine
print(paste('Before ITEA:',CAM_output_cosine))
print(paste('After ITEA:',CAM_ITEA_output_cosine))
```

Graphical illustration of the cell-type scatter plot of CAM3.0, with and without applying ITEA:
```{r CAM3.0 Plot 1, warning=FALSE,fig.height=7, fig.width=7, fig.align='left'}
# Without ITEA
scatter_plot(rCAM@ASestResult[[1]]@Sest[,order(order_output)],mg.info = TRUE,mg=cot$mg.list)
```

```{r CAM3.0 Plot 2, warning=FALSE,fig.height=7, fig.width=7, fig.align='left'}
# With ITEA
scatter_plot(test_result$`S list`[[test_result[[4]]]][,order(order_ITEA_output)],mg.info = TRUE,mg=cot$mg.list)

```

Similarly, we can apply ITEA to other deconvolution methods like **PREDE**:
```{r PREDE, eval=FALSE}
#### With ITEA ####
test_result<-ITEA(X=X_input,K=K,iCEG_thres=0.95,iteration=20,removal = 1,
                     deconvo_func = PREDE,
                     deconvo_param = list(Y=X_input,W1=NULL,type = "GE",K=5,iters = 50,rssDiffStop=1e-5),
                     feat_sele_func = select_feature,
                     feat_sele_param = list(mat = X_input,method = "cv",nmarker = 1000,startn = 0),
                     A_deconvo = '$H')
```

**RefFreeEWAS** by Houseman et al., 2016
```{r RefFreeEWAS, eval=FALSE}
#### With ITEA ####
test_result<-ITEA(X=X_input,K=K,iCEG_thres=0.98,iteration=20,removal = 1,
                   deconvo_func = RefFreeCellMix,
                   deconvo_param = list(Y = X_input, K = 5, verbose = FALSE),
                   feat_sele_func = select_most_variant,
                   feat_sele_param = list(input=X_input,k=10000),
                   A_deconvo = '$Omega')
```

**TOAST** by
```{r TOAST, eval=FALSE}
#### With ITEA ####
test_result<-ITEA(X=X_input,K=K,iCEG_thres=0.95,iteration=20,removal=2,
                   deconvo_func = csDeconv,deconvo_param =list(Y_raw=X_input, K=5, TotalIter = 30, 
                                                               bound_negative = TRUE, nMarker = 2000),
                   feat_sele_func = findRefinx,feat_sele_param = list(rawdata=X_input, nmarker = 5000),
                   A_deconvo = '$estProp')
```
