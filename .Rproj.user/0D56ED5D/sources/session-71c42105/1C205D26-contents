---
title: "ITEA User Maunal"
author: "Dongping Du"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{ITEA User Maunal}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

Cell-type asymmetry in expression profiles can substantially impact the outcomes of reference-free deconvolution. To address this, we proposed ITEA which aims to enhance the accuracy of proportion inference under the influence of cell-type asymmetry. ITEA iteratively identifies Consistently Expressed Genes (CEGs) across the cell-type expression profiles in S after each round of deconvolution and uses these CEGs to normalize the bulk expression matrix X.

## Quick Start
You can install the latest version of ITEA from GitHub by
```{r, eval = FALSE}
devtools::install_github("niccolodpdu/ITEA")
```

## Loading simulated proportion matrix A
The sample-wise cell-type proportion matrix is simulated by the Dirichlet distribution function. Dirichlet distribution allows an overall balanced cell-type proportion among samples without assuming the existence of ‘ideally pure samples’ of certain cell types, as in most cases pure samples are not available or unknown for the deconvolution. We set α (the parameter controlling the shape of the distribution) at 3 for all cell types in our simulation to make sure the proportions among samples are basically concentrated towards the center and mutually symmetric. Here we provide an example A matrix for users’ reference.
```{r, eval = FALSE}
## Read-in
library(ITEA)
A<-ITEA::sample_proportion_matrix

```

## Loading pre-processed cell-type specific expression profiles from GSE73721
The synthetic bulk data X is generated by multiplying the cell type specific expression profiles S extracted from real-world genomics data with a simulated sample-wise cell-type proportion matrix A. In this manual the cell type specific expression profiles are extracted from GSE73721, an expression profiling on RNA-Seq of human brain cells. Five cell types were extracted from the original data: HepaCAM positive cells (Astrocyte), GalC positive cells (Oligodendrocyte), CD45 positive cells (Myeloid), BSL bound cells (Endothelial), and O4 positive cells (Oligodendrocyte), all from adult temporal lobe. Here we provided an pre-processed example cell-type specific expression profile for users to use as a reference.
```{r, eval = FALSE}
## Read-in
S<-ITEA::sample_expression_profile

# Visualizing S matrix and the cell-type specific markers
cot<-cotMG(Sest=S,cos.thres=0.5,top=1500)
scatter_plot(S,mg.info = TRUE,mg=cot$mg.list)

# Mixing S and A into X
X <- S %*% t(A)
```

## Applying ITEA on four different unsupervised deconvolution algorithms
To validate the applicability of ITEA on different unsupervised deconvolution algorithms, we included four popular methods (CAM3.0, TOAST, PREDE, RefFreeEWAS). Three of these methods embedded specific feature selection units as a part of their procedure (PREDE, TOAST, RefFreeEWAS), which were also integrated into the ITEA pipeline.
```{r, warning=FALSE,fig.height=5, fig.width=6, fig.align='left'}
## Loading necessary libraries
library(CAM3)
library(PREDE)
library(debCAM)
library(TOAST)
library(preprocessCore)
```
CAM3.0 by Wu et al., 2024
```{r, warning=FALSE,fig.height=5, fig.width=6, fig.align='left'}
### CAM3.0
data_input<-X

#### Without ITEA ####
rCAM<-CAM3Run(data=data_input, K=5, dim.rdc = 10, thres.low = 0.3, thres.high = 0.99,
                 cluster.method = 'Fixed-Radius', fast.mode = TRUE,
                 radius.thres = 0.99, sim.thres = 0.98, cluster.num = 30,
                 MG.num.thres = 5, sample.weight = NULL, generalNMF = FALSE)

A_CAM<-rCAM@ASestResult[[1]]@Aest

# Correlation score
cor_CAM<-cor(A_CAM, A)
CAM_output_cor<-mean(apply(cor_CAM, 2, max))

# RMSE
order_output<-apply(cor_CAM,1,function(x) which.max(x))
CAM_output_rmse<-sqrt(mean((A_CAM[,order(order_output)] - A)^2))

# Cosine
cosine<-matrix(nrow=dim(A)[2],ncol=dim(A)[2])
for (i in 1:dim(A)[2]){
  for (j in 1:dim(A)[2]){
    cosine[i,j]<-mycosine(A[,i],A_CAM[,j])
  }
}
CAM_output_cosine<-mean(apply(cosine,2,max))

#### With ITEA ####
test_result<-ITEA(X=data_input,K=K,iCEG_thres=0.95,iteration=20,removal = 1,
                     deconvo_func = CAM3Run,
                     deconvo_param = list(data=data_input,K=5, dim.rdc = 10, thres.low = 0.3, thres.high = 0.99, 
                                          fast.mode = TRUE,radius.thres = 0.99, sim.thres = 0.98, cluster.num = 30,
                                          MG.num.thres = 5,sample.weight = NULL, generalNMF = FALSE),
                     A_deconvo = '@ASestResult[[1]]@Aest',
                     S_deconvo = '@ASestResult[[1]]@Sest')

A_CAM_ITEA<-test_result[[1]][[as.numeric(test_result[[4]])]]

# Correlation score
cor_CAM_ITEA<-cor(A_CAM_ITEA, A)
CAM_ITEA_output_cor<-mean(apply(cor_CAM_ITEA, 2, max))

# RMSE
order_ITEA_output<-apply(cor_CAM_ITEA,1,function(x) which.max(x))
CAM_ITEA_output_rmse<-sqrt(mean((A_CAM_ITEA[,order(order_ITEA_output)] - A)^2))

# Cosine
cosine<-matrix(nrow=dim(A)[2],ncol=dim(A)[2])
for (i in 1:dim(A)[2]){
  for (j in 1:dim(A)[2]){
    cosine[i,j]<-mycosine(A[,i],A_CAM_ITEA[,j])
  }
}
CAM_ITEA_output_cosine<-mean(apply(cosine,2,max))

#### Quantitative Evaluation ####
# Correlation Score
CAM_output_cor
CAM_ITEA_output_cor

# RMSE
CAM_output_rmse
CAM_ITEA_output_rmse

# Cosine
CAM_output_cosine
CAM_ITEA_output_cosine

#### Visualization of S ####
# Without ITEA
scatter_plot(rCAM@ASestResult[[1]]@Sest[,order(order_output)],mg.info = TRUE,mg=cot$mg.list)

# With ITEA
scatter_plot(test_result$`S list`[[test_result[[4]]]][,order(order_ITEA_output)],mg.info = TRUE,mg=cot$mg.list)

```
PREDE by 
```{r, warning=FALSE,fig.height=5, fig.width=6, fig.align='left'}
### PREDE
X_input<-X
data_input<-X_input/max(X_input)

#### Without ITEA ####
feat <- select_feature(mat = data_input,method = "cv",nmarker = 1000,startn = 0)
pred <- PREDE(data_input[feat,],W1=NULL,type = "GE",K=K,iters = 50,rssDiffStop=1e-5)
S_PREDE<-apply(as.matrix(X), 1, function(x) (nnls::nnls(t(pred$H),x))$x)
A_PREDE<-t(pred$H)

# Correlation Score
cor_PREDE<-cor(A_PREDE, A)
PREDE_output_cor<-mean(apply(cor_PREDE, 2, max))

# RMSE
order_PREDE<-apply(cor_PREDE,1,function(x) which.max(x))
PREDE_output_rmse<-sqrt(mean((A_PREDE[,order(order_PREDE)] - A)^2))

# Cosine
cosine<-matrix(nrow=dim(A)[2],ncol=dim(A)[2])
for (i in 1:dim(A)[2]){
  for (j in 1:dim(A)[2]){
    cosine[i,j]<-mycosine(A[,i],A_PREDE[,j])
  }
}
PREDE_output_cosine<-mean(apply(cosine,2,max))

#### With ITEA ####
test_result<-ITEA(X=X_input,K=K,iCEG_thres=0.95,iteration=20,removal = 1,
                     deconvo_func = PREDE,
                     deconvo_param = list(Y=X_input,W1=NULL,type = "GE",K=K,iters = 50,rssDiffStop=1e-5),
                     feat_sele_func = select_feature,
                     feat_sele_param = list(mat = X_input,method = "cv",nmarker = 1000,startn = 0),
                     A_deconvo = '$H')

A_PREDE_ITEA<-test_result[[1]][[as.numeric(test_result[[4]])]]

# Correlation Score
cor_PREDE_ITEA<-cor(A_PREDE_ITEA, A)
PREDE_ITEA_output_cor<-mean(apply(cor_PREDE_ITEA, 2, max))

# RMSE
order_PREDE_ITEA<-apply(cor_PREDE_ITEA,1,function(x) which.max(x))
PREDE_ITEA_output_rmse<-sqrt(mean((A_PREDE_ITEA[,order(order_PREDE_ITEA)] - A)^2))

# Cosine
cosine<-matrix(nrow=dim(A)[2],ncol=dim(A)[2])
for (i in 1:dim(A)[2]){
  for (j in 1:dim(A)[2]){
    cosine[i,j]<-mycosine(A[,i],A_PREDE_ITEA[,j])
  }
}
PREDE_ITEA_output_cosine<-mean(apply(cosine,2,max))

#### Quantitative Evaluation ####
# Correlation Score
PREDE_output_cor
PREDE_ITEA_output_cor

# RMSE
PREDE_output_rmse
PREDE_ITEA_output_rmse

# Cosine
PREDE_output_cosine
PREDE_ITEA_output_cosine

#### Visualization of S ####
# Without ITEA
scatter_plot(t(S_PREDE)[,order(order_PREDE)],mg.info = TRUE, mg=cot$mg.list)

# With ITEA
scatter_plot(test_result$`S list`[[test_result[[4]]]][,order(order_PREDE_ITEA)],mg.info = TRUE,mg=cot$mg.list)
```
RefFreeEWAS by Houseman et al., 2016
```{r, warning=FALSE,fig.height=5, fig.width=6, fig.align='left'}
### RefFreeEWAS
X_input<-X
data_input<-X_input/max(X_input)

#### Without ITEA ####
variance <- apply(data_input, 1, var, na.rm = TRUE)
most_variant_10k <- data_input[names(variance[order(variance, decreasing = TRUE)][1:10000]), ]

cell_mix <- RefFreeCellMix(Y = most_variant_10k, K = K, verbose = FALSE)
A_RefFreeEWAS <- cell_mix$Omega
S_RefFreeEWAS <- tryCatch({
  t(NMF::.fcnnls(A_RefFreeEWAS, t(data_input))$coef)
}, error = function(msg) {
  return(t(apply(data_input, 1, function(x) (nnls::nnls(A_RefFreeEWAS,x))$x)))
})

# Correlation Score
cor_RefFreeEWAS<-cor(A_RefFreeEWAS, A)
RefFreeEWAS_output_cor<-mean(apply(cor_RefFreeEWAS, 2, max))

# RMSE
order_RefFreeEWAS<-apply(cor_RefFreeEWAS,1,function(x) which.max(x))
RefFreeEWAS_output_rmse<-sqrt(mean((A_RefFreeEWAS[,order(order_RefFreeEWAS)] - A)^2))

# Cosine
cosine<-matrix(nrow=dim(A)[2],ncol=dim(A)[2])
for (i in 1:dim(A)[2]){
  for (j in 1:dim(A)[2]){
    cosine[i,j]<-mycosine(A[,i],A_RefFreeEWAS[,j])
  }
}
RefFreeEWAS_output_cosine<-mean(apply(cosine,2,max))

#### With ITEA ####

test_result<-ITEA(X=X_input,K=K,iCEG_thres=0.98,iteration=20,removal = 1,
                   deconvo_func = RefFreeCellMix,
                   deconvo_param = list(Y = X_input, K = K, verbose = FALSE),
                   feat_sele_func = select_most_variant,
                   feat_sele_param = list(input=X_input,k=10000),
                   A_deconvo = '$Omega')

A_ITEA<-test_result$`A list`[[test_result[[4]]]]

# Correlation Score
cor_RefFreeEWAS<-cor(A_ITEA, A)
RefFreeEWAS_ITEA_output_cor<-mean(apply(cor_RefFreeEWAS, 2, max))

# RMSE
order_RefFreeEWAS_ITEA<-apply(cor_RefFreeEWAS,1,function(x) which.max(x))
RefFreeEWAS_ITEA_output_rmse<-sqrt(mean((A_ITEA[,order(order_RefFreeEWAS_ITEA)] - A)^2))

# Cosine
cosine<-matrix(nrow=dim(A)[2],ncol=dim(A)[2])
for (i in 1:dim(A)[2]){
  for (j in 1:dim(A)[2]){
    cosine[i,j]<-mycosine(A[,i],A_ITEA[,j])
  }
}
RefFreeEWAS_ITEA_output_cosine<-mean(apply(cosine,2,max))

#### Quantitative Evaluation ####
# Correlation Score
RefFreeEWAS_output_cor
RefFreeEWAS_ITEA_output_cor

# RMSE
RefFreeEWAS_output_rmse
RefFreeEWAS_ITEA_output_rmse

# Cosine
RefFreeEWAS_output_cosine
RefFreeEWAS_ITEA_output_cosine

#### Visualization of S ####
# Without ITEA
scatter_plot(S_RefFreeEWAS[,order(order_RefFreeEWAS)],mg.info = TRUE,mg=cot$mg.list)

# With ITEA
scatter_plot(test_result$`S list`[[test_result[[4]]]][,order(order_RefFreeEWAS_ITEA)],mg.info = TRUE,mg=cot$mg.list)
```
TOAST by 
```{r, warning=FALSE,fig.height=5, fig.width=6, fig.align='left'}
### TOAST
X_input<-X

#### Without ITEA ####
refinx <- findRefinx(X_input, nmarker = 5000) # Feature selection
data_input<-X_input[refinx,]
data_input<-data_input/max(data_input)
outRF1 <- csDeconv(data_input, K=K, TotalIter = 30, bound_negative = TRUE, nMarker = 2000) 
A_TOAST<- outRF1$estProp
S_TOAST <- tryCatch({
  t(NMF::.fcnnls(A_TOAST, t(X_input))$coef)
}, error = function(msg) {
  return(t(apply(X_input, 1, function(x) (nnls::nnls(A_TOAST,x))$x)))
})

# Correlation Score
cor_TOAST<-cor(A_TOAST, A)
TOAST_output_cor<-mean(apply(cor_TOAST, 2, max))

# RMSE
order_TOAST<-apply(cor_TOAST,1,function(x) which.max(x))
TOAST_output_rmse<-sqrt(mean((A_TOAST[,order(order_TOAST)] - A)^2))

# Cosine
cosine<-matrix(nrow=dim(A)[2],ncol=dim(A)[2])
for (i in 1:dim(A)[2]){
  for (j in 1:dim(A)[2]){
    cosine[i,j]<-mycosine(A[,i],A_TOAST[,j])
  }
}
TOAST_output_cosine<-mean(apply(cosine,2,max))

#### With ITEA ####
test_result<-ITEA(X=X_input,K=K,iCEG_thres=0.95,iteration=20,removal=2,
                   deconvo_func = csDeconv,deconvo_param =list(Y_raw=X_input, K=K, TotalIter = 30, 
                                                               bound_negative = TRUE, nMarker = 2000),
                   feat_sele_func = findRefinx,feat_sele_param = list(rawdata=X_input, nmarker = 5000),
                   A_deconvo = '$estProp')

A_ITEA<-test_result$`A list`[[test_result[[4]]]]

# Correlation Score
cor_TOAST_ITEA<-cor(A_ITEA, A)
TOAST_ITEA_output_cor<-mean(apply(cor_TOAST_ITEA, 2, max))

# RMSE
order_TOAST_ITEA<-apply(cor_TOAST_ITEA,1,function(x) which.max(x))
TOAST_ITEA_output_rmse<-sqrt(mean((A_ITEA[,order(order_TOAST_ITEA)] - A)^2))

# Cosine
cosine<-matrix(nrow=dim(A)[2],ncol=dim(A)[2])
for (i in 1:dim(A)[2]){
  for (j in 1:dim(A)[2]){
    cosine[i,j]<-mycosine(A[,i],A_ITEA[,j])
  }
}
TOAST_ITEA_output_cosine<-mean(apply(cosine,2,max))

#### Quantitative Evaluation ####
# Correlation Score
TOAST_output_cor
TOAST_ITEA_output_cor

# RMSE
TOAST_output_rmse
TOAST_ITEA_output_rmse

# Cosine
TOAST_output_cosine
TOAST_ITEA_output_cosine

#### Visualization of S ####
# Without ITEA
scatter_plot(S_TOAST[,order(order_TOAST)],mg.info = TRUE, mg=cot$mg.list)

# With ITEA
scatter_plot(test_result$`S list`[[test_result[[4]]]][,order(order_TOAST_ITEA)],mg.info = TRUE,mg=cot$mg.list)
```
